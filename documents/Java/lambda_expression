***이 글은 모던 자바 인 액션을 참고해서 쓴 글입니다.***
# 1. 람다 표현식
## 1.0 개요 
    익명 클래스로 다양한 동작을 구현할수 있지만 만족할 만큼 코드가 깔금하지 않다.
    이는 자바 8의 새로운 기능인 람다 표현식을 이용해서 익명 클래스처럼 이름이 없는
    함수 이면서 메서드를 인수로 깔금하게 전달할 수 있다.
### 1.1 람다란 무엇인가?
    람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이다,
    람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 혈식, 예외리스트를 가질수 있다.
    
    1. 익명 - 보통의 메서드와 달리 이름이 없으면 익명이라고 표현한다,
    2. 함수 - 람다는 메서드처럼 클래스에 종속되지 않으므로 함수라고 호칭한다.
    3. 전달 - 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
    4. 간결성 - 자질구레한 코드를 구현할 필요가 없다.
    
    예시로 기존 코드를 람다 코드로 변환해보자
```java
기존 코드
Comparator<Apple> byWeight = new Comparator<Apple>() {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
}

람다 코드
Comparator<Apple> byWeight = 
    (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```
    코드가 훨신 간단해지고 명확해 졌다. 람다 표현식을 이용하면 compare 메서드의 바디를
    직접 전달하는것 처럼 코드를 전달할 수 있다.
    람다의 문법은 다음과 같이 표현할수 있다.
    1. (parameters) -> expression
    2. (parameters) -> { statements; }
    
    람다는 다음과 같은 사용 사례가 있다.

    1. 불리언 표현식
        (List<String> list) -> list.isEmpty()
    2. 객체 생성
        () -> new Apple(10)
    3. 객체에서 소비
        (Apple a) -> { System.out.println(a.getWeight()); }
    4. 객체에서 선택/추출
        (String s) -> s.length()
    5. 두 값을 조합
        (int a, int b) -> a * b
    두 객체 비교
        (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())
### 1.2 어디에, 어떻게 람다를 사용할까?
    정확히 람다는 함수형 인터페이스라는 문맵에서 사용할 수 있다.
    그럼 함수형 인터페이스라는것은 어떤것일까?
    대표적으로 객체를 받아 불리언으로 반환해주는 Predicate<T>가 함수형 인터페이스 이다
```java
public interface Predicate<T>{
    boolean test (T t);
}
```
    간단히 말해서 정확히 하나의 추상 메서드를 지정하는 인터페이스 이다.
    Predicate<T> 외에도 Comparator, Runnable 등이 있다.
    그럼 함수형 인터페이스로는 무엇을 할 수 있을까?
    람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로
    전체 표현식을 함수형 인터페이스를 구현한 클래스의 인스턴스로 취급할 수 있다.
    다음과 같이 Runnable 인터페이스 예제를 보자
```java
Runnable r1 = () -> System.out.println("Hello World 1");
Runnable r2 = new Runnable() {
    public void run() {
        System.out.println("Hello World 2");
    }
};
public static void process(Runnalbe r) {
    r.run();
}
process(r1);
process(r2);
process(() -> System.out.println("Hello World 3"));
```
    함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다,
    람더 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 하는데,
    예를 들어 Runnable 인터페이스의 추상 메서드 run은 인수와 반환값이 없으므로
    Runnable 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있다.
    
    함수 인터페이스는 @Functionallnterface 어노테이션으로 표현할수 있는데,
    @Functionallnterface로 인터페이스를 선언했찌만 실제로 함수형 인터페이스가 아니라면
    컴퍼일러가 에러는 발생시킨다,
### 1.3 람다 활용 : 실행 어라운드 패턴
~
    
    
    
    
